<?php
/**
 * @file
 * ESI handler for panel panes.
 *
 * Architectural philosophy:
 * - Assuming the "standard" panel renderer is used:
 *   - panels_renderer_standard::render_pane() takes rendered content generated
 *     by panels_renderer_standard::render_pane_content() and adds panel
 *     styles, controls pane-titles, etc.
 *   - panels_renderer_standard::render_pane_content() is where the ctools
 *     content-type renderer is invoked. This is also where panels checks for
 *     cached content, before invoking the ctools renderer if it's absent.
 *     After the content is rendered, hook_panels_pane_content_alter() is
 *     called, followed by $cache->set_cache().
 *   - panels_renderer_standard::render_layout() invokes render_panes() and
 *     render_regions() immediately afterwards.  The ideal place to substitute
 *     an ESI tag is between these two calls.
 *   - render_pane() must be invoked on the original pane, if features such as
 *     title-bubbling (where a pane title is promoted to be the title of the
 *     panel) are to succeed.
 * - The "esi" display-renderer (a render pipeline) is used to override the
 *   "standard" renderer, and replace the panes in between render_panes() and
 *   render_regions().
 * - The "panel_context" task handler is altered, replacing the standard save()
 *   implementation with a custom handler, which checks for ESI panes, and
 *   overrides the render pipeline if necessary.
 * - The rendered-pane of an ESI pane is replaced with a plain ESI tag; no
 *   theme furniture is provided around the tag. The ESI callback provides any
 *   necessary theme furniture.
 * - It's possible for themes to provide custom region-renderers, which are
 *   aware of the contents of individual panes, and overrides them. This
 *   functionality is not supported with ESI: panes *must* be capable of
 *   independent rendering.
 * - Cacheing controls and contexts are dictated by:
 *   - Block configuration (in the case of panes which are implementations of a
 *     standard Drupal block).
 *   - Context (where the ctools content_type declares a context as required or
 *     optional, and the panel has provided the context to the pane).
 *   - Pane visibility (where access to panes is controlled by roles or
 *     permissions).
 *   - User-defined overrides in the ESI cacheing configuration.
 */

// Tested against 1.7.2.
define('ESI_PANELS_REQUIRED_CTOOLS_API', '1.7.2');

/**
 * Implements hook_hook_info().
 */
function esi_panels_hook_info() {
  // Look for hook_esi_panels_context_arguments() in xxx.esi_panels.inc.
  $hooks['esi_panels_context_arguments'] = array(
    'group' => 'esi_panels',
  );
  return $hooks;
}

/**
 * Implements hook_esi_component().
 *
 * @see esi_block_prepare()
 * @see esi_block_render()
 */
function esi_panels_esi_component_info() {
  return array(
    'panels_pane' => array(
      'preprocess' => 'esi_panels__esi_pane_prepare',
      'render'     => 'esi_panels__esi_pane_render',
      'flush'      => 'esi_panels__esi_pane_flush',
      'file'       => 'esi_panels.esi.inc',
    ),
  );
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function esi_panels_form_panels_panel_context_edit_settings_alter(&$form, &$form_state) {
  // The 'ESI' panels renderer should automatically replace the 'standard'
  // panels renderer when there are panes on a panel which are handled by ESI.
  // It should not be selectable in its own right.
  unset($form['conf']['pipeline']['#options']['esi']);
  if ($form['conf']['pipeline']['#default_value'] == 'esi') {
    $form['conf']['pipeline']['#default_value'] = 'standard';
  }
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function esi_panels_ctools_plugin_directory($module, $plugin) {
  // Safety: go away if CTools is not at an appropriate version.
  if (!module_invoke('ctools', 'api_version', ESI_PANELS_REQUIRED_CTOOLS_API)) {
    return;
  }

  // We don't support the 'ctools' 'cache' plugin and pretending to causes
  // errors when they're in use.
  if ($module == 'ctools' && $plugin == 'cache') {
    return;
    // If we did we'd make a plugin/ctools_cache or something.
  }

  if ($module == 'page_manager' || $module == 'panels' || $module == 'ctools') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Implements hook_ctools_plugin_type().
 *
 * Register display_renderer plugin types.
 */
function esi_panels_ctools_plugin_type() {
  return array(
    'display_renderers' => array(
      'classes' => array('renderer'),
    ),
  );
}

/**
 * Implements hook_ctools_plugin_api().
 *
 * Inform CTools about version information for various plugins implemented by
 * Panels.
 *
 * @param string $owner
 *   The system name of the module owning the API about which information is
 *   being requested.
 * @param string $api
 *   The name of the API about which information is being requested.
 */
function esi_panels_ctools_plugin_api($owner, $api) {
  if ($owner == 'panels' && $api == 'pipelines') {
    return array(
      'version' => 1,
    );
  }
}

/**
 * Implements hook_ctools_plugin_post_alter().
 */
function esi_panels_ctools_plugin_post_alter(&$plugin, &$info) {
  // Every time the configuration of a panel is saved, the default hook on the
  // panel-context is invoked.  Replace that hook, in order to check for the
  // presence of ESI panes, and switch the rendering pipeline if necessary.
  if ($plugin['name'] == 'panel_context') {
    // Replace the default 'save' operation - panels_panel_context_save();
    $plugin['save'] = 'esi_panels__panel_context_save';
  }
}


/**
 * Build the URL to use for this ESI component.
 *
 * @return string
 *   The internal URL. Generate a fully-qualified path by running through url().
 */
function esi_panels_url($pane, $display) {
  // ESI 7 takes advantage of addressable content URLs.
  // Addressable content URLs contain context and args.
  // Default:         esi/panels_pane/theme:addressable_url
  // Cached per page: esi/panels_pane/theme:addressable_url/[base64($_GET['q'])]
  global $theme;
  $url = "esi/panels_pane/" . $theme . ":";

  // If the display reports that it has addressable content, make use of that.
  if ($display->renderer_handler && $address = $display->renderer_handler->address) {
    $url .= implode('::', array(
      $address,
      $pane->pid,
    ));
  }

  // Always add the current page URL.
  $url .= '/' . base64_encode($_GET['q']);

  // Allow other modules to alter the ESI URL (or respond to it).
  // @see hook_esi_block_url_alter().
  drupal_alter('esi_panels_url', $url);

  return $url;
}

/**
 * Save the configuration of a panel page.
 * @see panels_panel_context_save()
 */
function esi_panels__panel_context_save(&$handler, $update) {
  // Override the rendering pipeline if any pane uses ESI.
  // Only the standard rendering pipeline is supported; alternative/IPE/legacy
  // pipelines cannot be used with ESI.
  // @TODO: inform the user of this on the display, if a non-standard renderer
  // is selected.
  if ($handler->conf['pipeline'] == 'standard' && _esi_panels__display_uses_esi($handler->conf['display'])) {
    $handler->conf['pipeline'] = 'esi';
  }
  panels_panel_context_save($handler, $update);
}

/**
 * Check if any panes are configured to use ESI.
 *
 * @param ibject $display
 *   A panels_display object.
 *
 * @return boolean
 *   Whether any panes use the ESI cache.
 */
function _esi_panels__display_uses_esi(panels_display $display) {
  // Iterate each pane.
  foreach ($display->content as $pid => $pane) {
    // Any single pane implementing ESI is enough to return TRUE.
    // Allow other cache plugins whose names start with "esi".
    if (!empty($pane->cache) && strpos($pane->cache['method'], 'esi') === 0) {
      return TRUE;
    }
  }

  return FALSE;
}
